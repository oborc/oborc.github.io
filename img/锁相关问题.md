# 锁相关问题

### Synchronized

synchronized 关键字可以保证在同一时刻，只有一个线程可以执行某个方法或者代码块。同时，可以保证一个线程的变化被其他线程看到。

#### synchronized修饰实例方法：

**作用于当前实例加锁**，进入同步代码前要获得当前实例的锁

用synchronized 修饰实例对象中的实例方法。不包括静态方法。

```java
public class synchClass{
    static int i=0;
    public synchronized void A() {
        i++;
    }
    
    public void B(){
        System.out.println(Thread.currentThread.getName());
    }
    
    @Override
    public void run(){
       for(int j=0;j<1000000;j++){
            A();
        }  
        B();
    }
}

public void main(String[] args){
    synchClass test = new synchClass();
    Thread thread1 = Thread(test);
    Thread thread2 = Thread(test);
    
    thread1.start();
    thread2.start();
    thread1.join();
    thread2.join();
}
```

在类中的非static方法加上synchronized修饰，是在相当于在实例上加锁。一个线程拥有了该锁之后，别的线程不能进入到该实例用synchronized修饰的方法（一个对象只有一把锁，所以经分配出去了），但是可以进入没有synchronized修饰的方法（访问非修饰的方法不需要锁）。

在这里，有一个实例test,两个线程thread1 和 thread2来访问test实例。由于synchronized 修饰符修饰了A方法。所以，thread1在启动之后，thread2不能访问A方法，但是可以访问B方法。

![image-20190118142646097](/Users/haha/Documents/Learning/oborc.github.io/img/image-20190118142646097-7792806.png)



![image-20190118142713188](/Users/haha/Documents/Learning/oborc.github.io/img/image-20190118142713188-7792833.png)

这个结果是以上代码的不同运行结果，可以看到：在有synchronized修饰的函数A中，线程是串行执行的（结果是200000而不是比200000小），但是没有synchronized修饰的函数B，线程的执行顺序是随机的。

#### synchronized作用于静态方法

synchronized**作用于当前类对象加锁**，进入同步代码前要获得当前类对象的锁。

作用于静态方法，就相当于是当前类的对象锁。由于静态成员不专属于任何一个实例对象，是类成员，因此可以通过class对象锁来控制静态成员的并发操作。**当创建多个实例的时候，有一个线程获得了synchronized修饰的代码块或者函数的访问权限的时候，别的线程不能访问该代码块或者函数**。

#### synchronized**修饰代码块**

作用场景：

需要同步的代码只有一小部分，方法体比较大。

由于synchronized 修饰在代码块中，锁对象由代码块的位置决定，如果是在实例方法中，则锁是实例锁，在任何静态块或者静态方法中，锁是对象锁。



Synchronized的语义底层是通过一个monitor的对象来完成。其实wait/notify等方法也依赖于monitor对象，这就是为什么只有**在同步的块或者方法中才能调用wait/notify等方法**，否则会抛出java.lang.IllegalMonitorStateException的异常的原因



https://blog.csdn.net/javazejian/article/details/72828483

## Lock 接口 VS synchronized 关键字

- 类型：
  - Lock 为接口，有不同的实现类
  - synchronized 为关键字
- 锁的释放：
  - Lock 需要手动释放锁，即 `unLock()` 
  - synchronized 不需要手动释放锁，synchronized 代码块执行完，自动释放锁
- 等待的中断：
  - Lock 可以中断等待，即 `t.interrupt()` 
  - synchronized 会导致线程无限等待，不可中断
- **Lock 可以知道线程有没有成功获得锁，即 tryLock()，synchronized不支持**

## volatile

​	volatile:volatile 通过锁定内存或者缓存来实现原子性。一般情况下，操作会先写在缓存里，写入内存的时间并不是确定的，在多处理器的情况下，共享数据会出现并发问题。

​	如果用volatile申明之后，对于共享变量的操作会先写入内存，然后在根据缓存一致性，别的处理器会检查自己的缓存，如果发现缓存的内存区域发生变化，则会重新读区内存的数据到缓存中，从而保证一致性。达到了一个线程的操作别的线程可见的效果。

​	也有处理器对于volatile做了改进，如果要访问的区域已经存在缓存中，则先锁定缓存，再将缓存中的内容写入内存。再使用缓存一致性保证修改的原子性操作。

## 