# JVM

### 程序计数器

​	当前线程的字节码的行号指示器

### Java虚拟机栈

​	java虚拟机栈是线程 ==私有的==。java方法执行的时候的内存，每个方法在执行的时候都会有一个栈帧，里面存放**局部变量表**、操作数栈、动态链接、方法出口等。每个方法从调用到执行结束、对应栈帧在虚拟机栈的入栈和出栈的过程。==生命周期和线程相同==

​	局部变量表放了编译期间可知的数据类型。（**基本类型+对象引用类型**）

​	栈中通过栈指针用来存取，因此在编译期间就必须知道栈内所有数据的大小，来生成相应的代码，以便上下移动指针。（**基本数据类型和引用类型存在栈中，但是引用的对象不存在栈中**）

​	局部变量表在编译期间就确定了需要的内存大小，运行期间不会改变。

#### StackOverFlow

​	stackOverFlow是请求栈的深度大于虚拟机所允许的深度。

#### OutOfMemoryError

​	虚拟机栈可动态扩展，无法申请到足够的内存。

### 本地方法栈

​	为虚拟机使用到的native方法服务

### Java堆

​	==线程共享==。虚拟机启动时创建。

​	**编译器不需要知道对象在堆中的存活时间和大小**堆存储比栈存储更费时间。

### 方法区（included in heap）

​	==线程共享==存储已经被虚拟机加载的类信息、常量、静态变量、即时编译后的代码数据。

####  运行时常量池（方法区的一部分）

​	存放编译期间的各种字面量和符号引用。



### 对象的内存布局

对象在内存中分为3部分：

1. 对象头

   对象头包含运行时数据和类型指针：

   - 运行时数据：哈希码、GC分代年龄、锁状态标志
   - 类型指针：对象指向它的类元数据的指针，可以通过指针确定对象是哪个类的实例。查找对象的元数据信息不一定要经过对象本身。普通java对象的大小是通过元数据信息确认的。but 数组需要存储长度来计算大小。

2. 实例数据：是对象真正存储的有效信息。是定义的各种类型的字段内容。相同宽度的字段会被分配到一起，父类中的变量会出现在子类前面。

3. 对齐填充：对象的大小必须是8字节的整数倍

### 对象的访问定位

1. 句柄访问

   句柄池（在Java堆中）中存放对象实例数据的指针和对象类型数据的指针。通过这两个指针去拿去数据。对象数据永远存放在方法区。

2. 直接指针访问

   （Java堆中）对象类型数据的指针+对象实例数据。不需要去取对象实例数据，只需要去取类型。

句柄访问：reference中存储的是稳定的句柄地址，对象被移动只需要改变指针。

直接访问：速度快。

### 反射

### 泛型

提供了编译时类型安全检测，允许程序员在编译的时候检测到非法的类型。

本质是参数化类型。（顾名思义就是将类型-参数化-即类型可变）（**thinking of 安全检测**）

1. 泛型方法：

   方法在调用的时候可以接收不同类型的参数。根据传递给泛型方法的参数类型，处理每一个方法的调用。（类似于方法重载）但是比重载的范围更为广泛。重载必须是参数列表有确切的值，泛型方法只是参数泛型化。保证在编译期间不指定参数类型也能编译通过。

2. 泛型类

   申明部分包含一个参数，参数也是一个类型变量，用于指定一个泛型类型名称的标识符。 

   ![image-20181115115450564](/Users/haha/Documents/Learning/oborc.github.io/img/image-20181115115450564.png)

### 总结

栈：基本数据类型和引用放在栈中（）

堆：对象实例放在堆中