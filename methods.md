# 分治

### 最大N个数

思路：

利用快速排序，先排一次（从大到小），然后看key 在序列中的位置，如果key 的左边的个数==N。则输出左边的所以。

如果key 左边的个数大于N，对Key 的左边进行排序。

### 求排列的逆序数：

1. 分成两边，分别求左边的逆序数和右边的逆序数
2. 再算有多少逆序数是左半边取一个数和右半边取一个数组成。

关键：

如何实现步骤2

左半边和右半边都是排好序的。从左到右，左半边和右半边都各扫一遍。

归并排序的时候加上数逆序数

# 动态规划

### 数字三角形输出最大路径和

思路一：

用二维数组存放数字三角形：

D(r,j)第r行第j个数字。

max(r,j)	从D(r,j)到底边的各条路径中，最佳路径的数字之和。

递归：

从定点出发。下一步只走D(r+1,j)或者D(r+1,j+1)。

max(r,j) = max(max(r+1,j),max(r+1,j+1))

+D(r,j)

```java
int maxLength[][];
maxLength[r][j]=max(maxlength[r+1][j],maxlength(r+1,j+1))+D(r,j)
```



**以上思路用递归会超时，深度遍历每条路径，存在大量重复计算，时间复杂度为2的N次方**

记忆型递归：把重复计算的值保存起来。

用数组存起来最大值。如果已经算过，直接return。否则，计算当前点左右的最大值，和当前值相加，返回

递推方式：

#### 动态规划的思路：

 递归函数有N个参数，就定义N维的数组，数组的下标就是递归函数的参数的取值范围。数组元素的值是递归函数的返回值，这样就可以从边界值开始，逐步填充数组，相当于计算递归函数值的逆过程。

**状态**：子问题的解。所有的状态的集合构成问题的状态空间的大小。

问题的时间复杂度就是状态树木乘以计算每个状态所用的时间。

**确定状态，确定初识状态值，推算未知状态。初始状态放在状态数组里。用已知推未知**-->状态转移方程

**状态转移方程**

递推公式：计算状态并存起来，转移状态。或者别的循环，递推等。



动态规划问题特点：

- 具有最有子结构性质。问题具有最有子结构。问题最优解所包含的子问题的解也有最优解。
- 无后效性。当前的若干状态一旦确定，此后过程的演变就只和这若干个状态相关，和采取哪种手段和哪条路径演变到当前的状态没有关系。

### 最长上升子序列

分解问题，求每个点的最长上升子序列，初始值为1，如果当前点大于前一点，当前点的最长上升序列=当前点左边的最大最长上升序列加1.找不到则为1。

算法：

```java 
int maxLength[n]={1};
for(int i=0;i<n;i++)
{
    for(int j=0;j<i;j++)
    {
        if(a[i]>a[j])
            maxLength[i]=max(maxLength(i),maxLength(j)+1);
    }
}
```

###  最长公共子序列

```java 
//array1[i]和array2[j]前的最长公共子序列的长度。
maxLen[i][j]；
for（int i=0;i<length(array1);i++)
    maxLen[i][0]=0;

for（int i=0;i<length(array2);i++)
    maxLen[0][j]=0;

for(int i =1;i<=length1;i++) {
    for(int j =1;j<=length2;j++) {
        if(array1[i-1] == array[j-1]) {
            maxLen[i][j]=maxLen[i-1][j-1]+1;
        }else {
            maxLen[i][j] = max(maxLen[i-1][j],maxLen[i][j-1];)
        }
    }
}



```



### 最佳加法表达式

值最小的表达式

V(m,n)表示n个数字中插入M个加号所能形成的表达式的最小值。

v(m,n)=min{v(m-1,i),+num(i+1,n)}

(i=m...n-1)

在第M个数的右边加入第M个加号。

v(m,n)就是前m-1个加号组成的最小结果加上后面的字符组成的数字。

因为i的取值为在第M个数的右边放入加号的位置有m…n-1这么多的选择，所以要在最外面加一层取min 的算法。

<u>**此题中要找到状态转移和子问题，子问题就是通过加号来做截断。两个数之间的位置是有限的，就可以通过从第M个位置放入加号来解决随机放入加号的复杂度。放入一个加号后，前面的问题就会变为子问题**。</u>



动态规划：重点在于找到状态表示和

。是用最优子问题求解？找到无后效性的状态。状态在什么时候改变--》状态转移方程（递推-->方程式）



# 贪心算法

### 圣诞老人的礼物。最大价值

按礼物的价值/重量比从大到小依次选取礼物。

